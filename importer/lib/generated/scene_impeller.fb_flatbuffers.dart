// automatically generated by the FlatBuffers compiler, do not modify
// ignore_for_file: unused_import, unused_field, unused_element, unused_local_variable

library impeller.fb;

import 'dart:typed_data' show Uint8List;
import 'package:flutter_scene_importer/third_party/flat_buffers.dart' as fb;

class ComponentType {
  final int value;
  const ComponentType._(this.value);

  factory ComponentType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
      throw StateError('Invalid value $value for bit flag enum ComponentType');
    }
    return result;
  }

  static ComponentType? _createOrNull(int? value) =>
      value == null ? null : ComponentType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 1;
  static bool containsValue(int value) => values.containsKey(value);

  static const ComponentType k8Bit = ComponentType._(0);
  static const ComponentType k16Bit = ComponentType._(1);
  static const Map<int, ComponentType> values = {0: k8Bit, 1: k16Bit};

  static const fb.Reader<ComponentType> reader = _ComponentTypeReader();

  @override
  String toString() {
    return 'ComponentType{value: $value}';
  }
}

class _ComponentTypeReader extends fb.Reader<ComponentType> {
  const _ComponentTypeReader();

  @override
  int get size => 1;

  @override
  ComponentType read(fb.BufferContext bc, int offset) =>
      ComponentType.fromValue(const fb.Int8Reader().read(bc, offset));
}

class MaterialType {
  final int value;
  const MaterialType._(this.value);

  factory MaterialType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
      throw StateError('Invalid value $value for bit flag enum MaterialType');
    }
    return result;
  }

  static MaterialType? _createOrNull(int? value) =>
      value == null ? null : MaterialType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 1;
  static bool containsValue(int value) => values.containsKey(value);

  static const MaterialType kUnlit = MaterialType._(0);
  static const MaterialType kPhysicallyBased = MaterialType._(1);
  static const Map<int, MaterialType> values = {0: kUnlit, 1: kPhysicallyBased};

  static const fb.Reader<MaterialType> reader = _MaterialTypeReader();

  @override
  String toString() {
    return 'MaterialType{value: $value}';
  }
}

class _MaterialTypeReader extends fb.Reader<MaterialType> {
  const _MaterialTypeReader();

  @override
  int get size => 1;

  @override
  MaterialType read(fb.BufferContext bc, int offset) =>
      MaterialType.fromValue(const fb.Int8Reader().read(bc, offset));
}

class VertexBufferTypeId {
  final int value;
  const VertexBufferTypeId._(this.value);

  factory VertexBufferTypeId.fromValue(int value) {
    final result = values[value];
    if (result == null) {
      throw StateError(
          'Invalid value $value for bit flag enum VertexBufferTypeId');
    }
    return result;
  }

  static VertexBufferTypeId? _createOrNull(int? value) =>
      value == null ? null : VertexBufferTypeId.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 2;
  static bool containsValue(int value) => values.containsKey(value);

  static const VertexBufferTypeId NONE = VertexBufferTypeId._(0);
  static const VertexBufferTypeId UnskinnedVertexBuffer =
      VertexBufferTypeId._(1);
  static const VertexBufferTypeId SkinnedVertexBuffer = VertexBufferTypeId._(2);
  static const Map<int, VertexBufferTypeId> values = {
    0: NONE,
    1: UnskinnedVertexBuffer,
    2: SkinnedVertexBuffer
  };

  static const fb.Reader<VertexBufferTypeId> reader =
      _VertexBufferTypeIdReader();

  @override
  String toString() {
    return 'VertexBufferTypeId{value: $value}';
  }
}

class _VertexBufferTypeIdReader extends fb.Reader<VertexBufferTypeId> {
  const _VertexBufferTypeIdReader();

  @override
  int get size => 1;

  @override
  VertexBufferTypeId read(fb.BufferContext bc, int offset) =>
      VertexBufferTypeId.fromValue(const fb.Uint8Reader().read(bc, offset));
}

class IndexType {
  final int value;
  const IndexType._(this.value);

  factory IndexType.fromValue(int value) {
    final result = values[value];
    if (result == null) {
      throw StateError('Invalid value $value for bit flag enum IndexType');
    }
    return result;
  }

  static IndexType? _createOrNull(int? value) =>
      value == null ? null : IndexType.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 1;
  static bool containsValue(int value) => values.containsKey(value);

  static const IndexType k16Bit = IndexType._(0);
  static const IndexType k32Bit = IndexType._(1);
  static const Map<int, IndexType> values = {0: k16Bit, 1: k32Bit};

  static const fb.Reader<IndexType> reader = _IndexTypeReader();

  @override
  String toString() {
    return 'IndexType{value: $value}';
  }
}

class _IndexTypeReader extends fb.Reader<IndexType> {
  const _IndexTypeReader();

  @override
  int get size => 1;

  @override
  IndexType read(fb.BufferContext bc, int offset) =>
      IndexType.fromValue(const fb.Int8Reader().read(bc, offset));
}

class KeyframesTypeId {
  final int value;
  const KeyframesTypeId._(this.value);

  factory KeyframesTypeId.fromValue(int value) {
    final result = values[value];
    if (result == null) {
      throw StateError(
          'Invalid value $value for bit flag enum KeyframesTypeId');
    }
    return result;
  }

  static KeyframesTypeId? _createOrNull(int? value) =>
      value == null ? null : KeyframesTypeId.fromValue(value);

  static const int minValue = 0;
  static const int maxValue = 3;
  static bool containsValue(int value) => values.containsKey(value);

  static const KeyframesTypeId NONE = KeyframesTypeId._(0);
  static const KeyframesTypeId TranslationKeyframes = KeyframesTypeId._(1);
  static const KeyframesTypeId RotationKeyframes = KeyframesTypeId._(2);
  static const KeyframesTypeId ScaleKeyframes = KeyframesTypeId._(3);
  static const Map<int, KeyframesTypeId> values = {
    0: NONE,
    1: TranslationKeyframes,
    2: RotationKeyframes,
    3: ScaleKeyframes
  };

  static const fb.Reader<KeyframesTypeId> reader = _KeyframesTypeIdReader();

  @override
  String toString() {
    return 'KeyframesTypeId{value: $value}';
  }
}

class _KeyframesTypeIdReader extends fb.Reader<KeyframesTypeId> {
  const _KeyframesTypeIdReader();

  @override
  int get size => 1;

  @override
  KeyframesTypeId read(fb.BufferContext bc, int offset) =>
      KeyframesTypeId.fromValue(const fb.Uint8Reader().read(bc, offset));
}

///  Materials.
///
class Color {
  Color._(this._bc, this._bcOffset);

  static const fb.Reader<Color> reader = _ColorReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  double get r => const fb.Float32Reader().read(_bc, _bcOffset + 0);
  double get g => const fb.Float32Reader().read(_bc, _bcOffset + 4);
  double get b => const fb.Float32Reader().read(_bc, _bcOffset + 8);
  double get a => const fb.Float32Reader().read(_bc, _bcOffset + 12);

  @override
  String toString() {
    return 'Color{r: ${r}, g: ${g}, b: ${b}, a: ${a}}';
  }

  ColorT unpack() => ColorT(r: r, g: g, b: b, a: a);

  static int pack(fb.Builder fbBuilder, ColorT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

///  Materials.
///
class ColorT implements fb.Packable {
  double r;
  double g;
  double b;
  double a;

  ColorT({required this.r, required this.g, required this.b, required this.a});

  @override
  int pack(fb.Builder fbBuilder) {
    fbBuilder.putFloat32(a);
    fbBuilder.putFloat32(b);
    fbBuilder.putFloat32(g);
    fbBuilder.putFloat32(r);
    return fbBuilder.offset;
  }

  @override
  String toString() {
    return 'ColorT{r: ${r}, g: ${g}, b: ${b}, a: ${a}}';
  }
}

class _ColorReader extends fb.StructReader<Color> {
  const _ColorReader();

  @override
  int get size => 16;

  @override
  Color createObject(fb.BufferContext bc, int offset) => Color._(bc, offset);
}

class ColorBuilder {
  ColorBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  int finish(double r, double g, double b, double a) {
    fbBuilder.putFloat32(a);
    fbBuilder.putFloat32(b);
    fbBuilder.putFloat32(g);
    fbBuilder.putFloat32(r);
    return fbBuilder.offset;
  }
}

class ColorObjectBuilder extends fb.ObjectBuilder {
  final double _r;
  final double _g;
  final double _b;
  final double _a;

  ColorObjectBuilder({
    required double r,
    required double g,
    required double b,
    required double a,
  })  : _r = r,
        _g = g,
        _b = b,
        _a = a;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.putFloat32(_a);
    fbBuilder.putFloat32(_b);
    fbBuilder.putFloat32(_g);
    fbBuilder.putFloat32(_r);
    return fbBuilder.offset;
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

class EmbeddedImage {
  EmbeddedImage._(this._bc, this._bcOffset);
  factory EmbeddedImage(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<EmbeddedImage> reader = _EmbeddedImageReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  List<int>? get bytes =>
      const fb.Uint8ListReader().vTableGetNullable(_bc, _bcOffset, 4);
  int get componentCount =>
      const fb.Uint8Reader().vTableGet(_bc, _bcOffset, 6, 0);
  ComponentType get componentType => ComponentType.fromValue(
      const fb.Int8Reader().vTableGet(_bc, _bcOffset, 8, 0));
  int get width => const fb.Uint32Reader().vTableGet(_bc, _bcOffset, 10, 0);
  int get height => const fb.Uint32Reader().vTableGet(_bc, _bcOffset, 12, 0);

  @override
  String toString() {
    return 'EmbeddedImage{bytes: ${bytes}, componentCount: ${componentCount}, componentType: ${componentType}, width: ${width}, height: ${height}}';
  }

  EmbeddedImageT unpack() => EmbeddedImageT(
      bytes: const fb.Uint8ListReader(lazy: false)
          .vTableGetNullable(_bc, _bcOffset, 4),
      componentCount: componentCount,
      componentType: componentType,
      width: width,
      height: height);

  static int pack(fb.Builder fbBuilder, EmbeddedImageT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class EmbeddedImageT implements fb.Packable {
  List<int>? bytes;
  int componentCount;
  ComponentType componentType;
  int width;
  int height;

  EmbeddedImageT(
      {this.bytes,
      this.componentCount = 0,
      this.componentType = ComponentType.k8Bit,
      this.width = 0,
      this.height = 0});

  @override
  int pack(fb.Builder fbBuilder) {
    final int? bytesOffset =
        bytes == null ? null : fbBuilder.writeListUint8(bytes!);
    fbBuilder.startTable(5);
    fbBuilder.addOffset(0, bytesOffset);
    fbBuilder.addUint8(1, componentCount);
    fbBuilder.addInt8(2, componentType.value);
    fbBuilder.addUint32(3, width);
    fbBuilder.addUint32(4, height);
    return fbBuilder.endTable();
  }

  @override
  String toString() {
    return 'EmbeddedImageT{bytes: ${bytes}, componentCount: ${componentCount}, componentType: ${componentType}, width: ${width}, height: ${height}}';
  }
}

class _EmbeddedImageReader extends fb.TableReader<EmbeddedImage> {
  const _EmbeddedImageReader();

  @override
  EmbeddedImage createObject(fb.BufferContext bc, int offset) =>
      EmbeddedImage._(bc, offset);
}

class EmbeddedImageBuilder {
  EmbeddedImageBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(5);
  }

  int addBytesOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }

  int addComponentCount(int? componentCount) {
    fbBuilder.addUint8(1, componentCount);
    return fbBuilder.offset;
  }

  int addComponentType(ComponentType? componentType) {
    fbBuilder.addInt8(2, componentType?.value);
    return fbBuilder.offset;
  }

  int addWidth(int? width) {
    fbBuilder.addUint32(3, width);
    return fbBuilder.offset;
  }

  int addHeight(int? height) {
    fbBuilder.addUint32(4, height);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class EmbeddedImageObjectBuilder extends fb.ObjectBuilder {
  final List<int>? _bytes;
  final int? _componentCount;
  final ComponentType? _componentType;
  final int? _width;
  final int? _height;

  EmbeddedImageObjectBuilder({
    List<int>? bytes,
    int? componentCount,
    ComponentType? componentType,
    int? width,
    int? height,
  })  : _bytes = bytes,
        _componentCount = componentCount,
        _componentType = componentType,
        _width = width,
        _height = height;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? bytesOffset =
        _bytes == null ? null : fbBuilder.writeListUint8(_bytes!);
    fbBuilder.startTable(5);
    fbBuilder.addOffset(0, bytesOffset);
    fbBuilder.addUint8(1, _componentCount);
    fbBuilder.addInt8(2, _componentType?.value);
    fbBuilder.addUint32(3, _width);
    fbBuilder.addUint32(4, _height);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

///  The `bytes` field takes precedent over the `uri` field.
///  If both the `uri` and `bytes` fields are empty, a fully opaque white
///  placeholder will be used.
class Texture {
  Texture._(this._bc, this._bcOffset);
  factory Texture(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Texture> reader = _TextureReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  ///  A Flutter asset URI for a compressed image file to import and decode.
  String? get uri =>
      const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 4);

  ///  Decompressed image bytes for uploading to the GPU. If this field is not
  ///  empty, it takes precedent over the `uri` field for sourcing the texture.
  EmbeddedImage? get embeddedImage =>
      EmbeddedImage.reader.vTableGetNullable(_bc, _bcOffset, 6);

  @override
  String toString() {
    return 'Texture{uri: ${uri}, embeddedImage: ${embeddedImage}}';
  }

  TextureT unpack() =>
      TextureT(uri: uri, embeddedImage: embeddedImage?.unpack());

  static int pack(fb.Builder fbBuilder, TextureT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

///  The `bytes` field takes precedent over the `uri` field.
///  If both the `uri` and `bytes` fields are empty, a fully opaque white
///  placeholder will be used.
class TextureT implements fb.Packable {
  ///  A Flutter asset URI for a compressed image file to import and decode.
  String? uri;

  ///  Decompressed image bytes for uploading to the GPU. If this field is not
  ///  empty, it takes precedent over the `uri` field for sourcing the texture.
  EmbeddedImageT? embeddedImage;

  TextureT({this.uri, this.embeddedImage});

  @override
  int pack(fb.Builder fbBuilder) {
    final int? uriOffset = uri == null ? null : fbBuilder.writeString(uri!);
    final int? embeddedImageOffset = embeddedImage?.pack(fbBuilder);
    fbBuilder.startTable(2);
    fbBuilder.addOffset(0, uriOffset);
    fbBuilder.addOffset(1, embeddedImageOffset);
    return fbBuilder.endTable();
  }

  @override
  String toString() {
    return 'TextureT{uri: ${uri}, embeddedImage: ${embeddedImage}}';
  }
}

class _TextureReader extends fb.TableReader<Texture> {
  const _TextureReader();

  @override
  Texture createObject(fb.BufferContext bc, int offset) =>
      Texture._(bc, offset);
}

class TextureBuilder {
  TextureBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(2);
  }

  int addUriOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }

  int addEmbeddedImageOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class TextureObjectBuilder extends fb.ObjectBuilder {
  final String? _uri;
  final EmbeddedImageObjectBuilder? _embeddedImage;

  TextureObjectBuilder({
    String? uri,
    EmbeddedImageObjectBuilder? embeddedImage,
  })  : _uri = uri,
        _embeddedImage = embeddedImage;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? uriOffset = _uri == null ? null : fbBuilder.writeString(_uri!);
    final int? embeddedImageOffset =
        _embeddedImage?.getOrCreateOffset(fbBuilder);
    fbBuilder.startTable(2);
    fbBuilder.addOffset(0, uriOffset);
    fbBuilder.addOffset(1, embeddedImageOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

///  The final color of each material component is the texture color multiplied
///  by the factor of the component.
///  Texture fields are indices into the `Scene`->`textures` array. All textures
///  are optional -- a texture index value of -1 indicates no texture.
class Material {
  Material._(this._bc, this._bcOffset);
  factory Material(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Material> reader = _MaterialReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  MaterialType get type => MaterialType.fromValue(
      const fb.Int8Reader().vTableGet(_bc, _bcOffset, 4, 0));
  Color? get baseColorFactor =>
      Color.reader.vTableGetNullable(_bc, _bcOffset, 6);
  int get baseColorTexture =>
      const fb.Int32Reader().vTableGet(_bc, _bcOffset, 8, -1);
  double get metallicFactor =>
      const fb.Float32Reader().vTableGet(_bc, _bcOffset, 10, 0.0);
  double get roughnessFactor =>
      const fb.Float32Reader().vTableGet(_bc, _bcOffset, 12, 0.5);
  int get metallicRoughnessTexture =>
      const fb.Int32Reader().vTableGet(_bc, _bcOffset, 14, -1);
  double get normalScale =>
      const fb.Float32Reader().vTableGet(_bc, _bcOffset, 16, 1.0);
  int get normalTexture =>
      const fb.Int32Reader().vTableGet(_bc, _bcOffset, 18, -1);
  Vec3? get emissiveFactor => Vec3.reader.vTableGetNullable(_bc, _bcOffset, 20);
  int get emissiveTexture =>
      const fb.Int32Reader().vTableGet(_bc, _bcOffset, 22, -1);
  double get occlusionStrength =>
      const fb.Float32Reader().vTableGet(_bc, _bcOffset, 24, 1.0);
  int get occlusionTexture =>
      const fb.Int32Reader().vTableGet(_bc, _bcOffset, 26, -1);

  @override
  String toString() {
    return 'Material{type: ${type}, baseColorFactor: ${baseColorFactor}, baseColorTexture: ${baseColorTexture}, metallicFactor: ${metallicFactor}, roughnessFactor: ${roughnessFactor}, metallicRoughnessTexture: ${metallicRoughnessTexture}, normalScale: ${normalScale}, normalTexture: ${normalTexture}, emissiveFactor: ${emissiveFactor}, emissiveTexture: ${emissiveTexture}, occlusionStrength: ${occlusionStrength}, occlusionTexture: ${occlusionTexture}}';
  }

  MaterialT unpack() => MaterialT(
      type: type,
      baseColorFactor: baseColorFactor?.unpack(),
      baseColorTexture: baseColorTexture,
      metallicFactor: metallicFactor,
      roughnessFactor: roughnessFactor,
      metallicRoughnessTexture: metallicRoughnessTexture,
      normalScale: normalScale,
      normalTexture: normalTexture,
      emissiveFactor: emissiveFactor?.unpack(),
      emissiveTexture: emissiveTexture,
      occlusionStrength: occlusionStrength,
      occlusionTexture: occlusionTexture);

  static int pack(fb.Builder fbBuilder, MaterialT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

///  The final color of each material component is the texture color multiplied
///  by the factor of the component.
///  Texture fields are indices into the `Scene`->`textures` array. All textures
///  are optional -- a texture index value of -1 indicates no texture.
class MaterialT implements fb.Packable {
  MaterialType type;
  ColorT? baseColorFactor;
  int baseColorTexture;
  double metallicFactor;
  double roughnessFactor;
  int metallicRoughnessTexture;
  double normalScale;
  int normalTexture;
  Vec3T? emissiveFactor;
  int emissiveTexture;
  double occlusionStrength;
  int occlusionTexture;

  MaterialT(
      {this.type = MaterialType.kUnlit,
      this.baseColorFactor,
      this.baseColorTexture = -1,
      this.metallicFactor = 0.0,
      this.roughnessFactor = 0.5,
      this.metallicRoughnessTexture = -1,
      this.normalScale = 1.0,
      this.normalTexture = -1,
      this.emissiveFactor,
      this.emissiveTexture = -1,
      this.occlusionStrength = 1.0,
      this.occlusionTexture = -1});

  @override
  int pack(fb.Builder fbBuilder) {
    fbBuilder.startTable(12);
    fbBuilder.addInt8(0, type.value);
    if (baseColorFactor != null) {
      fbBuilder.addStruct(1, baseColorFactor!.pack(fbBuilder));
    }
    fbBuilder.addInt32(2, baseColorTexture);
    fbBuilder.addFloat32(3, metallicFactor);
    fbBuilder.addFloat32(4, roughnessFactor);
    fbBuilder.addInt32(5, metallicRoughnessTexture);
    fbBuilder.addFloat32(6, normalScale);
    fbBuilder.addInt32(7, normalTexture);
    if (emissiveFactor != null) {
      fbBuilder.addStruct(8, emissiveFactor!.pack(fbBuilder));
    }
    fbBuilder.addInt32(9, emissiveTexture);
    fbBuilder.addFloat32(10, occlusionStrength);
    fbBuilder.addInt32(11, occlusionTexture);
    return fbBuilder.endTable();
  }

  @override
  String toString() {
    return 'MaterialT{type: ${type}, baseColorFactor: ${baseColorFactor}, baseColorTexture: ${baseColorTexture}, metallicFactor: ${metallicFactor}, roughnessFactor: ${roughnessFactor}, metallicRoughnessTexture: ${metallicRoughnessTexture}, normalScale: ${normalScale}, normalTexture: ${normalTexture}, emissiveFactor: ${emissiveFactor}, emissiveTexture: ${emissiveTexture}, occlusionStrength: ${occlusionStrength}, occlusionTexture: ${occlusionTexture}}';
  }
}

class _MaterialReader extends fb.TableReader<Material> {
  const _MaterialReader();

  @override
  Material createObject(fb.BufferContext bc, int offset) =>
      Material._(bc, offset);
}

class MaterialBuilder {
  MaterialBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(12);
  }

  int addType(MaterialType? type) {
    fbBuilder.addInt8(0, type?.value);
    return fbBuilder.offset;
  }

  int addBaseColorFactor(int offset) {
    fbBuilder.addStruct(1, offset);
    return fbBuilder.offset;
  }

  int addBaseColorTexture(int? baseColorTexture) {
    fbBuilder.addInt32(2, baseColorTexture);
    return fbBuilder.offset;
  }

  int addMetallicFactor(double? metallicFactor) {
    fbBuilder.addFloat32(3, metallicFactor);
    return fbBuilder.offset;
  }

  int addRoughnessFactor(double? roughnessFactor) {
    fbBuilder.addFloat32(4, roughnessFactor);
    return fbBuilder.offset;
  }

  int addMetallicRoughnessTexture(int? metallicRoughnessTexture) {
    fbBuilder.addInt32(5, metallicRoughnessTexture);
    return fbBuilder.offset;
  }

  int addNormalScale(double? normalScale) {
    fbBuilder.addFloat32(6, normalScale);
    return fbBuilder.offset;
  }

  int addNormalTexture(int? normalTexture) {
    fbBuilder.addInt32(7, normalTexture);
    return fbBuilder.offset;
  }

  int addEmissiveFactor(int offset) {
    fbBuilder.addStruct(8, offset);
    return fbBuilder.offset;
  }

  int addEmissiveTexture(int? emissiveTexture) {
    fbBuilder.addInt32(9, emissiveTexture);
    return fbBuilder.offset;
  }

  int addOcclusionStrength(double? occlusionStrength) {
    fbBuilder.addFloat32(10, occlusionStrength);
    return fbBuilder.offset;
  }

  int addOcclusionTexture(int? occlusionTexture) {
    fbBuilder.addInt32(11, occlusionTexture);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class MaterialObjectBuilder extends fb.ObjectBuilder {
  final MaterialType? _type;
  final ColorObjectBuilder? _baseColorFactor;
  final int? _baseColorTexture;
  final double? _metallicFactor;
  final double? _roughnessFactor;
  final int? _metallicRoughnessTexture;
  final double? _normalScale;
  final int? _normalTexture;
  final Vec3ObjectBuilder? _emissiveFactor;
  final int? _emissiveTexture;
  final double? _occlusionStrength;
  final int? _occlusionTexture;

  MaterialObjectBuilder({
    MaterialType? type,
    ColorObjectBuilder? baseColorFactor,
    int? baseColorTexture,
    double? metallicFactor,
    double? roughnessFactor,
    int? metallicRoughnessTexture,
    double? normalScale,
    int? normalTexture,
    Vec3ObjectBuilder? emissiveFactor,
    int? emissiveTexture,
    double? occlusionStrength,
    int? occlusionTexture,
  })  : _type = type,
        _baseColorFactor = baseColorFactor,
        _baseColorTexture = baseColorTexture,
        _metallicFactor = metallicFactor,
        _roughnessFactor = roughnessFactor,
        _metallicRoughnessTexture = metallicRoughnessTexture,
        _normalScale = normalScale,
        _normalTexture = normalTexture,
        _emissiveFactor = emissiveFactor,
        _emissiveTexture = emissiveTexture,
        _occlusionStrength = occlusionStrength,
        _occlusionTexture = occlusionTexture;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.startTable(12);
    fbBuilder.addInt8(0, _type?.value);
    if (_baseColorFactor != null) {
      fbBuilder.addStruct(1, _baseColorFactor!.finish(fbBuilder));
    }
    fbBuilder.addInt32(2, _baseColorTexture);
    fbBuilder.addFloat32(3, _metallicFactor);
    fbBuilder.addFloat32(4, _roughnessFactor);
    fbBuilder.addInt32(5, _metallicRoughnessTexture);
    fbBuilder.addFloat32(6, _normalScale);
    fbBuilder.addInt32(7, _normalTexture);
    if (_emissiveFactor != null) {
      fbBuilder.addStruct(8, _emissiveFactor!.finish(fbBuilder));
    }
    fbBuilder.addInt32(9, _emissiveTexture);
    fbBuilder.addFloat32(10, _occlusionStrength);
    fbBuilder.addInt32(11, _occlusionTexture);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

///  Geometry.
///
class Vec2 {
  Vec2._(this._bc, this._bcOffset);

  static const fb.Reader<Vec2> reader = _Vec2Reader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  double get x => const fb.Float32Reader().read(_bc, _bcOffset + 0);
  double get y => const fb.Float32Reader().read(_bc, _bcOffset + 4);

  @override
  String toString() {
    return 'Vec2{x: ${x}, y: ${y}}';
  }

  Vec2T unpack() => Vec2T(x: x, y: y);

  static int pack(fb.Builder fbBuilder, Vec2T? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

///  Geometry.
///
class Vec2T implements fb.Packable {
  double x;
  double y;

  Vec2T({required this.x, required this.y});

  @override
  int pack(fb.Builder fbBuilder) {
    fbBuilder.putFloat32(y);
    fbBuilder.putFloat32(x);
    return fbBuilder.offset;
  }

  @override
  String toString() {
    return 'Vec2T{x: ${x}, y: ${y}}';
  }
}

class _Vec2Reader extends fb.StructReader<Vec2> {
  const _Vec2Reader();

  @override
  int get size => 8;

  @override
  Vec2 createObject(fb.BufferContext bc, int offset) => Vec2._(bc, offset);
}

class Vec2Builder {
  Vec2Builder(this.fbBuilder);

  final fb.Builder fbBuilder;

  int finish(double x, double y) {
    fbBuilder.putFloat32(y);
    fbBuilder.putFloat32(x);
    return fbBuilder.offset;
  }
}

class Vec2ObjectBuilder extends fb.ObjectBuilder {
  final double _x;
  final double _y;

  Vec2ObjectBuilder({
    required double x,
    required double y,
  })  : _x = x,
        _y = y;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.putFloat32(_y);
    fbBuilder.putFloat32(_x);
    return fbBuilder.offset;
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

class Vec3 {
  Vec3._(this._bc, this._bcOffset);

  static const fb.Reader<Vec3> reader = _Vec3Reader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  double get x => const fb.Float32Reader().read(_bc, _bcOffset + 0);
  double get y => const fb.Float32Reader().read(_bc, _bcOffset + 4);
  double get z => const fb.Float32Reader().read(_bc, _bcOffset + 8);

  @override
  String toString() {
    return 'Vec3{x: ${x}, y: ${y}, z: ${z}}';
  }

  Vec3T unpack() => Vec3T(x: x, y: y, z: z);

  static int pack(fb.Builder fbBuilder, Vec3T? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class Vec3T implements fb.Packable {
  double x;
  double y;
  double z;

  Vec3T({required this.x, required this.y, required this.z});

  @override
  int pack(fb.Builder fbBuilder) {
    fbBuilder.putFloat32(z);
    fbBuilder.putFloat32(y);
    fbBuilder.putFloat32(x);
    return fbBuilder.offset;
  }

  @override
  String toString() {
    return 'Vec3T{x: ${x}, y: ${y}, z: ${z}}';
  }
}

class _Vec3Reader extends fb.StructReader<Vec3> {
  const _Vec3Reader();

  @override
  int get size => 12;

  @override
  Vec3 createObject(fb.BufferContext bc, int offset) => Vec3._(bc, offset);
}

class Vec3Builder {
  Vec3Builder(this.fbBuilder);

  final fb.Builder fbBuilder;

  int finish(double x, double y, double z) {
    fbBuilder.putFloat32(z);
    fbBuilder.putFloat32(y);
    fbBuilder.putFloat32(x);
    return fbBuilder.offset;
  }
}

class Vec3ObjectBuilder extends fb.ObjectBuilder {
  final double _x;
  final double _y;
  final double _z;

  Vec3ObjectBuilder({
    required double x,
    required double y,
    required double z,
  })  : _x = x,
        _y = y,
        _z = z;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.putFloat32(_z);
    fbBuilder.putFloat32(_y);
    fbBuilder.putFloat32(_x);
    return fbBuilder.offset;
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

class Vec4 {
  Vec4._(this._bc, this._bcOffset);

  static const fb.Reader<Vec4> reader = _Vec4Reader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  double get x => const fb.Float32Reader().read(_bc, _bcOffset + 0);
  double get y => const fb.Float32Reader().read(_bc, _bcOffset + 4);
  double get z => const fb.Float32Reader().read(_bc, _bcOffset + 8);
  double get w => const fb.Float32Reader().read(_bc, _bcOffset + 12);

  @override
  String toString() {
    return 'Vec4{x: ${x}, y: ${y}, z: ${z}, w: ${w}}';
  }

  Vec4T unpack() => Vec4T(x: x, y: y, z: z, w: w);

  static int pack(fb.Builder fbBuilder, Vec4T? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class Vec4T implements fb.Packable {
  double x;
  double y;
  double z;
  double w;

  Vec4T({required this.x, required this.y, required this.z, required this.w});

  @override
  int pack(fb.Builder fbBuilder) {
    fbBuilder.putFloat32(w);
    fbBuilder.putFloat32(z);
    fbBuilder.putFloat32(y);
    fbBuilder.putFloat32(x);
    return fbBuilder.offset;
  }

  @override
  String toString() {
    return 'Vec4T{x: ${x}, y: ${y}, z: ${z}, w: ${w}}';
  }
}

class _Vec4Reader extends fb.StructReader<Vec4> {
  const _Vec4Reader();

  @override
  int get size => 16;

  @override
  Vec4 createObject(fb.BufferContext bc, int offset) => Vec4._(bc, offset);
}

class Vec4Builder {
  Vec4Builder(this.fbBuilder);

  final fb.Builder fbBuilder;

  int finish(double x, double y, double z, double w) {
    fbBuilder.putFloat32(w);
    fbBuilder.putFloat32(z);
    fbBuilder.putFloat32(y);
    fbBuilder.putFloat32(x);
    return fbBuilder.offset;
  }
}

class Vec4ObjectBuilder extends fb.ObjectBuilder {
  final double _x;
  final double _y;
  final double _z;
  final double _w;

  Vec4ObjectBuilder({
    required double x,
    required double y,
    required double z,
    required double w,
  })  : _x = x,
        _y = y,
        _z = z,
        _w = w;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.putFloat32(_w);
    fbBuilder.putFloat32(_z);
    fbBuilder.putFloat32(_y);
    fbBuilder.putFloat32(_x);
    return fbBuilder.offset;
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

class Vertex {
  Vertex._(this._bc, this._bcOffset);

  static const fb.Reader<Vertex> reader = _VertexReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  Vec3 get position => Vec3.reader.read(_bc, _bcOffset + 0);
  Vec3 get normal => Vec3.reader.read(_bc, _bcOffset + 12);
  Vec2 get textureCoords => Vec2.reader.read(_bc, _bcOffset + 24);
  Color get color => Color.reader.read(_bc, _bcOffset + 32);

  @override
  String toString() {
    return 'Vertex{position: ${position}, normal: ${normal}, textureCoords: ${textureCoords}, color: ${color}}';
  }

  VertexT unpack() => VertexT(
      position: position.unpack(),
      normal: normal.unpack(),
      textureCoords: textureCoords.unpack(),
      color: color.unpack());

  static int pack(fb.Builder fbBuilder, VertexT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class VertexT implements fb.Packable {
  Vec3T position;
  Vec3T normal;
  Vec2T textureCoords;
  ColorT color;

  VertexT(
      {required this.position,
      required this.normal,
      required this.textureCoords,
      required this.color});

  @override
  int pack(fb.Builder fbBuilder) {
    color.pack(fbBuilder);
    textureCoords.pack(fbBuilder);
    normal.pack(fbBuilder);
    position.pack(fbBuilder);
    return fbBuilder.offset;
  }

  @override
  String toString() {
    return 'VertexT{position: ${position}, normal: ${normal}, textureCoords: ${textureCoords}, color: ${color}}';
  }
}

class _VertexReader extends fb.StructReader<Vertex> {
  const _VertexReader();

  @override
  int get size => 48;

  @override
  Vertex createObject(fb.BufferContext bc, int offset) => Vertex._(bc, offset);
}

class VertexBuilder {
  VertexBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  int finish(fb.StructBuilder position, fb.StructBuilder normal,
      fb.StructBuilder textureCoords, fb.StructBuilder color) {
    color();
    textureCoords();
    normal();
    position();
    return fbBuilder.offset;
  }
}

class VertexObjectBuilder extends fb.ObjectBuilder {
  final Vec3ObjectBuilder _position;
  final Vec3ObjectBuilder _normal;
  final Vec2ObjectBuilder _textureCoords;
  final ColorObjectBuilder _color;

  VertexObjectBuilder({
    required Vec3ObjectBuilder position,
    required Vec3ObjectBuilder normal,
    required Vec2ObjectBuilder textureCoords,
    required ColorObjectBuilder color,
  })  : _position = position,
        _normal = normal,
        _textureCoords = textureCoords,
        _color = color;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    _color.finish(fbBuilder);
    _textureCoords.finish(fbBuilder);
    _normal.finish(fbBuilder);
    _position.finish(fbBuilder);
    return fbBuilder.offset;
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

class UnskinnedVertexBuffer {
  UnskinnedVertexBuffer._(this._bc, this._bcOffset);
  factory UnskinnedVertexBuffer(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<UnskinnedVertexBuffer> reader =
      _UnskinnedVertexBufferReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  List<int>? get vertices =>
      const fb.Uint8ListReader().vTableGetNullable(_bc, _bcOffset, 4);
  int get vertexCount =>
      const fb.Uint32Reader().vTableGet(_bc, _bcOffset, 6, 0);

  @override
  String toString() {
    return 'UnskinnedVertexBuffer{vertices: ${vertices}, vertexCount: ${vertexCount}}';
  }

  UnskinnedVertexBufferT unpack() => UnskinnedVertexBufferT(
      vertices: const fb.Uint8ListReader(lazy: false)
          .vTableGetNullable(_bc, _bcOffset, 4),
      vertexCount: vertexCount);

  static int pack(fb.Builder fbBuilder, UnskinnedVertexBufferT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class UnskinnedVertexBufferT implements fb.Packable {
  List<int>? vertices;
  int vertexCount;

  UnskinnedVertexBufferT({this.vertices, this.vertexCount = 0});

  @override
  int pack(fb.Builder fbBuilder) {
    final int? verticesOffset =
        vertices == null ? null : fbBuilder.writeListUint8(vertices!);
    fbBuilder.startTable(2);
    fbBuilder.addOffset(0, verticesOffset);
    fbBuilder.addUint32(1, vertexCount);
    return fbBuilder.endTable();
  }

  @override
  String toString() {
    return 'UnskinnedVertexBufferT{vertices: ${vertices}, vertexCount: ${vertexCount}}';
  }
}

class _UnskinnedVertexBufferReader
    extends fb.TableReader<UnskinnedVertexBuffer> {
  const _UnskinnedVertexBufferReader();

  @override
  UnskinnedVertexBuffer createObject(fb.BufferContext bc, int offset) =>
      UnskinnedVertexBuffer._(bc, offset);
}

class UnskinnedVertexBufferBuilder {
  UnskinnedVertexBufferBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(2);
  }

  int addVerticesOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }

  int addVertexCount(int? vertexCount) {
    fbBuilder.addUint32(1, vertexCount);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class UnskinnedVertexBufferObjectBuilder extends fb.ObjectBuilder {
  final List<int>? _vertices;
  final int? _vertexCount;

  UnskinnedVertexBufferObjectBuilder({
    List<int>? vertices,
    int? vertexCount,
  })  : _vertices = vertices,
        _vertexCount = vertexCount;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? verticesOffset =
        _vertices == null ? null : fbBuilder.writeListUint8(_vertices!);
    fbBuilder.startTable(2);
    fbBuilder.addOffset(0, verticesOffset);
    fbBuilder.addUint32(1, _vertexCount);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

class SkinnedVertex {
  SkinnedVertex._(this._bc, this._bcOffset);

  static const fb.Reader<SkinnedVertex> reader = _SkinnedVertexReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  Vertex get vertex => Vertex.reader.read(_bc, _bcOffset + 0);

  ///  Four joint indices corresponding to this mesh's skin transforms. These
  ///  are floats instead of ints because this vertex data is uploaded directly
  ///  to the GPU, and float attributes work for all Impeller backends.
  Vec4 get joints => Vec4.reader.read(_bc, _bcOffset + 48);

  ///  Four weight values that specify the influence of the corresponding
  ///  joints.
  Vec4 get weights => Vec4.reader.read(_bc, _bcOffset + 64);

  @override
  String toString() {
    return 'SkinnedVertex{vertex: ${vertex}, joints: ${joints}, weights: ${weights}}';
  }

  SkinnedVertexT unpack() => SkinnedVertexT(
      vertex: vertex.unpack(),
      joints: joints.unpack(),
      weights: weights.unpack());

  static int pack(fb.Builder fbBuilder, SkinnedVertexT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class SkinnedVertexT implements fb.Packable {
  VertexT vertex;

  ///  Four joint indices corresponding to this mesh's skin transforms. These
  ///  are floats instead of ints because this vertex data is uploaded directly
  ///  to the GPU, and float attributes work for all Impeller backends.
  Vec4T joints;

  ///  Four weight values that specify the influence of the corresponding
  ///  joints.
  Vec4T weights;

  SkinnedVertexT(
      {required this.vertex, required this.joints, required this.weights});

  @override
  int pack(fb.Builder fbBuilder) {
    weights.pack(fbBuilder);
    joints.pack(fbBuilder);
    vertex.pack(fbBuilder);
    return fbBuilder.offset;
  }

  @override
  String toString() {
    return 'SkinnedVertexT{vertex: ${vertex}, joints: ${joints}, weights: ${weights}}';
  }
}

class _SkinnedVertexReader extends fb.StructReader<SkinnedVertex> {
  const _SkinnedVertexReader();

  @override
  int get size => 80;

  @override
  SkinnedVertex createObject(fb.BufferContext bc, int offset) =>
      SkinnedVertex._(bc, offset);
}

class SkinnedVertexBuilder {
  SkinnedVertexBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  int finish(fb.StructBuilder vertex, fb.StructBuilder joints,
      fb.StructBuilder weights) {
    weights();
    joints();
    vertex();
    return fbBuilder.offset;
  }
}

class SkinnedVertexObjectBuilder extends fb.ObjectBuilder {
  final VertexObjectBuilder _vertex;
  final Vec4ObjectBuilder _joints;
  final Vec4ObjectBuilder _weights;

  SkinnedVertexObjectBuilder({
    required VertexObjectBuilder vertex,
    required Vec4ObjectBuilder joints,
    required Vec4ObjectBuilder weights,
  })  : _vertex = vertex,
        _joints = joints,
        _weights = weights;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    _weights.finish(fbBuilder);
    _joints.finish(fbBuilder);
    _vertex.finish(fbBuilder);
    return fbBuilder.offset;
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

class SkinnedVertexBuffer {
  SkinnedVertexBuffer._(this._bc, this._bcOffset);
  factory SkinnedVertexBuffer(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<SkinnedVertexBuffer> reader =
      _SkinnedVertexBufferReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  List<int>? get vertices =>
      const fb.Uint8ListReader().vTableGetNullable(_bc, _bcOffset, 4);
  int get vertexCount =>
      const fb.Uint32Reader().vTableGet(_bc, _bcOffset, 6, 0);

  @override
  String toString() {
    return 'SkinnedVertexBuffer{vertices: ${vertices}, vertexCount: ${vertexCount}}';
  }

  SkinnedVertexBufferT unpack() => SkinnedVertexBufferT(
      vertices: const fb.Uint8ListReader(lazy: false)
          .vTableGetNullable(_bc, _bcOffset, 4),
      vertexCount: vertexCount);

  static int pack(fb.Builder fbBuilder, SkinnedVertexBufferT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class SkinnedVertexBufferT implements fb.Packable {
  List<int>? vertices;
  int vertexCount;

  SkinnedVertexBufferT({this.vertices, this.vertexCount = 0});

  @override
  int pack(fb.Builder fbBuilder) {
    final int? verticesOffset =
        vertices == null ? null : fbBuilder.writeListUint8(vertices!);
    fbBuilder.startTable(2);
    fbBuilder.addOffset(0, verticesOffset);
    fbBuilder.addUint32(1, vertexCount);
    return fbBuilder.endTable();
  }

  @override
  String toString() {
    return 'SkinnedVertexBufferT{vertices: ${vertices}, vertexCount: ${vertexCount}}';
  }
}

class _SkinnedVertexBufferReader extends fb.TableReader<SkinnedVertexBuffer> {
  const _SkinnedVertexBufferReader();

  @override
  SkinnedVertexBuffer createObject(fb.BufferContext bc, int offset) =>
      SkinnedVertexBuffer._(bc, offset);
}

class SkinnedVertexBufferBuilder {
  SkinnedVertexBufferBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(2);
  }

  int addVerticesOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }

  int addVertexCount(int? vertexCount) {
    fbBuilder.addUint32(1, vertexCount);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class SkinnedVertexBufferObjectBuilder extends fb.ObjectBuilder {
  final List<int>? _vertices;
  final int? _vertexCount;

  SkinnedVertexBufferObjectBuilder({
    List<int>? vertices,
    int? vertexCount,
  })  : _vertices = vertices,
        _vertexCount = vertexCount;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? verticesOffset =
        _vertices == null ? null : fbBuilder.writeListUint8(_vertices!);
    fbBuilder.startTable(2);
    fbBuilder.addOffset(0, verticesOffset);
    fbBuilder.addUint32(1, _vertexCount);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

class Indices {
  Indices._(this._bc, this._bcOffset);
  factory Indices(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Indices> reader = _IndicesReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  List<int>? get data =>
      const fb.Uint8ListReader().vTableGetNullable(_bc, _bcOffset, 4);
  int get count => const fb.Uint32Reader().vTableGet(_bc, _bcOffset, 6, 0);
  IndexType get type => IndexType.fromValue(
      const fb.Int8Reader().vTableGet(_bc, _bcOffset, 8, 0));

  @override
  String toString() {
    return 'Indices{data: ${data}, count: ${count}, type: ${type}}';
  }

  IndicesT unpack() => IndicesT(
      data: const fb.Uint8ListReader(lazy: false)
          .vTableGetNullable(_bc, _bcOffset, 4),
      count: count,
      type: type);

  static int pack(fb.Builder fbBuilder, IndicesT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class IndicesT implements fb.Packable {
  List<int>? data;
  int count;
  IndexType type;

  IndicesT({this.data, this.count = 0, this.type = IndexType.k16Bit});

  @override
  int pack(fb.Builder fbBuilder) {
    final int? dataOffset =
        data == null ? null : fbBuilder.writeListUint8(data!);
    fbBuilder.startTable(3);
    fbBuilder.addOffset(0, dataOffset);
    fbBuilder.addUint32(1, count);
    fbBuilder.addInt8(2, type.value);
    return fbBuilder.endTable();
  }

  @override
  String toString() {
    return 'IndicesT{data: ${data}, count: ${count}, type: ${type}}';
  }
}

class _IndicesReader extends fb.TableReader<Indices> {
  const _IndicesReader();

  @override
  Indices createObject(fb.BufferContext bc, int offset) =>
      Indices._(bc, offset);
}

class IndicesBuilder {
  IndicesBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(3);
  }

  int addDataOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }

  int addCount(int? count) {
    fbBuilder.addUint32(1, count);
    return fbBuilder.offset;
  }

  int addType(IndexType? type) {
    fbBuilder.addInt8(2, type?.value);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class IndicesObjectBuilder extends fb.ObjectBuilder {
  final List<int>? _data;
  final int? _count;
  final IndexType? _type;

  IndicesObjectBuilder({
    List<int>? data,
    int? count,
    IndexType? type,
  })  : _data = data,
        _count = count,
        _type = type;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? dataOffset =
        _data == null ? null : fbBuilder.writeListUint8(_data!);
    fbBuilder.startTable(3);
    fbBuilder.addOffset(0, dataOffset);
    fbBuilder.addUint32(1, _count);
    fbBuilder.addInt8(2, _type?.value);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

class MeshPrimitive {
  MeshPrimitive._(this._bc, this._bcOffset);
  factory MeshPrimitive(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<MeshPrimitive> reader = _MeshPrimitiveReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  VertexBufferTypeId? get verticesType => VertexBufferTypeId._createOrNull(
      const fb.Uint8Reader().vTableGetNullable(_bc, _bcOffset, 4));
  dynamic get vertices {
    switch (verticesType?.value) {
      case 1:
        return UnskinnedVertexBuffer.reader
            .vTableGetNullable(_bc, _bcOffset, 6);
      case 2:
        return SkinnedVertexBuffer.reader.vTableGetNullable(_bc, _bcOffset, 6);
      default:
        return null;
    }
  }

  Indices? get indices => Indices.reader.vTableGetNullable(_bc, _bcOffset, 8);
  Material? get material =>
      Material.reader.vTableGetNullable(_bc, _bcOffset, 10);

  @override
  String toString() {
    return 'MeshPrimitive{verticesType: ${verticesType}, vertices: ${vertices}, indices: ${indices}, material: ${material}}';
  }

  MeshPrimitiveT unpack() => MeshPrimitiveT(
      verticesType: verticesType,
      vertices: vertices,
      indices: indices?.unpack(),
      material: material?.unpack());

  static int pack(fb.Builder fbBuilder, MeshPrimitiveT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class MeshPrimitiveT implements fb.Packable {
  VertexBufferTypeId? verticesType;
  dynamic vertices;
  IndicesT? indices;
  MaterialT? material;

  MeshPrimitiveT(
      {this.verticesType, this.vertices, this.indices, this.material});

  @override
  int pack(fb.Builder fbBuilder) {
    final int? verticesOffset = vertices?.pack(fbBuilder);
    final int? indicesOffset = indices?.pack(fbBuilder);
    final int? materialOffset = material?.pack(fbBuilder);
    fbBuilder.startTable(4);
    fbBuilder.addUint8(0, verticesType?.value);
    fbBuilder.addOffset(1, verticesOffset);
    fbBuilder.addOffset(2, indicesOffset);
    fbBuilder.addOffset(3, materialOffset);
    return fbBuilder.endTable();
  }

  @override
  String toString() {
    return 'MeshPrimitiveT{verticesType: ${verticesType}, vertices: ${vertices}, indices: ${indices}, material: ${material}}';
  }
}

class _MeshPrimitiveReader extends fb.TableReader<MeshPrimitive> {
  const _MeshPrimitiveReader();

  @override
  MeshPrimitive createObject(fb.BufferContext bc, int offset) =>
      MeshPrimitive._(bc, offset);
}

class MeshPrimitiveBuilder {
  MeshPrimitiveBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(4);
  }

  int addVerticesType(VertexBufferTypeId? verticesType) {
    fbBuilder.addUint8(0, verticesType?.value);
    return fbBuilder.offset;
  }

  int addVerticesOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }

  int addIndicesOffset(int? offset) {
    fbBuilder.addOffset(2, offset);
    return fbBuilder.offset;
  }

  int addMaterialOffset(int? offset) {
    fbBuilder.addOffset(3, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class MeshPrimitiveObjectBuilder extends fb.ObjectBuilder {
  final VertexBufferTypeId? _verticesType;
  final dynamic _vertices;
  final IndicesObjectBuilder? _indices;
  final MaterialObjectBuilder? _material;

  MeshPrimitiveObjectBuilder({
    VertexBufferTypeId? verticesType,
    dynamic vertices,
    IndicesObjectBuilder? indices,
    MaterialObjectBuilder? material,
  })  : _verticesType = verticesType,
        _vertices = vertices,
        _indices = indices,
        _material = material;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? verticesOffset = _vertices?.getOrCreateOffset(fbBuilder);
    final int? indicesOffset = _indices?.getOrCreateOffset(fbBuilder);
    final int? materialOffset = _material?.getOrCreateOffset(fbBuilder);
    fbBuilder.startTable(4);
    fbBuilder.addUint8(0, _verticesType?.value);
    fbBuilder.addOffset(1, verticesOffset);
    fbBuilder.addOffset(2, indicesOffset);
    fbBuilder.addOffset(3, materialOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

///  Animations.
///
class TranslationKeyframes {
  TranslationKeyframes._(this._bc, this._bcOffset);
  factory TranslationKeyframes(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<TranslationKeyframes> reader =
      _TranslationKeyframesReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  List<Vec3>? get values => const fb.ListReader<Vec3>(Vec3.reader)
      .vTableGetNullable(_bc, _bcOffset, 4);

  @override
  String toString() {
    return 'TranslationKeyframes{values: ${values}}';
  }

  TranslationKeyframesT unpack() =>
      TranslationKeyframesT(values: values?.map((e) => e.unpack()).toList());

  static int pack(fb.Builder fbBuilder, TranslationKeyframesT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

///  Animations.
///
class TranslationKeyframesT implements fb.Packable {
  List<Vec3T>? values;

  TranslationKeyframesT({this.values});

  @override
  int pack(fb.Builder fbBuilder) {
    int? valuesOffset;
    if (values != null) {
      for (var e in values!) {
        e.pack(fbBuilder);
      }
      valuesOffset = fbBuilder.endStructVector(values!.length);
    }
    fbBuilder.startTable(1);
    fbBuilder.addOffset(0, valuesOffset);
    return fbBuilder.endTable();
  }

  @override
  String toString() {
    return 'TranslationKeyframesT{values: ${values}}';
  }
}

class _TranslationKeyframesReader extends fb.TableReader<TranslationKeyframes> {
  const _TranslationKeyframesReader();

  @override
  TranslationKeyframes createObject(fb.BufferContext bc, int offset) =>
      TranslationKeyframes._(bc, offset);
}

class TranslationKeyframesBuilder {
  TranslationKeyframesBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(1);
  }

  int addValuesOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class TranslationKeyframesObjectBuilder extends fb.ObjectBuilder {
  final List<Vec3ObjectBuilder>? _values;

  TranslationKeyframesObjectBuilder({
    List<Vec3ObjectBuilder>? values,
  }) : _values = values;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? valuesOffset =
        _values == null ? null : fbBuilder.writeListOfStructs(_values!);
    fbBuilder.startTable(1);
    fbBuilder.addOffset(0, valuesOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

class RotationKeyframes {
  RotationKeyframes._(this._bc, this._bcOffset);
  factory RotationKeyframes(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<RotationKeyframes> reader = _RotationKeyframesReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  List<Vec4>? get values => const fb.ListReader<Vec4>(Vec4.reader)
      .vTableGetNullable(_bc, _bcOffset, 4);

  @override
  String toString() {
    return 'RotationKeyframes{values: ${values}}';
  }

  RotationKeyframesT unpack() =>
      RotationKeyframesT(values: values?.map((e) => e.unpack()).toList());

  static int pack(fb.Builder fbBuilder, RotationKeyframesT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class RotationKeyframesT implements fb.Packable {
  List<Vec4T>? values;

  RotationKeyframesT({this.values});

  @override
  int pack(fb.Builder fbBuilder) {
    int? valuesOffset;
    if (values != null) {
      for (var e in values!) {
        e.pack(fbBuilder);
      }
      valuesOffset = fbBuilder.endStructVector(values!.length);
    }
    fbBuilder.startTable(1);
    fbBuilder.addOffset(0, valuesOffset);
    return fbBuilder.endTable();
  }

  @override
  String toString() {
    return 'RotationKeyframesT{values: ${values}}';
  }
}

class _RotationKeyframesReader extends fb.TableReader<RotationKeyframes> {
  const _RotationKeyframesReader();

  @override
  RotationKeyframes createObject(fb.BufferContext bc, int offset) =>
      RotationKeyframes._(bc, offset);
}

class RotationKeyframesBuilder {
  RotationKeyframesBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(1);
  }

  int addValuesOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class RotationKeyframesObjectBuilder extends fb.ObjectBuilder {
  final List<Vec4ObjectBuilder>? _values;

  RotationKeyframesObjectBuilder({
    List<Vec4ObjectBuilder>? values,
  }) : _values = values;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? valuesOffset =
        _values == null ? null : fbBuilder.writeListOfStructs(_values!);
    fbBuilder.startTable(1);
    fbBuilder.addOffset(0, valuesOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

class ScaleKeyframes {
  ScaleKeyframes._(this._bc, this._bcOffset);
  factory ScaleKeyframes(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<ScaleKeyframes> reader = _ScaleKeyframesReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  List<Vec3>? get values => const fb.ListReader<Vec3>(Vec3.reader)
      .vTableGetNullable(_bc, _bcOffset, 4);

  @override
  String toString() {
    return 'ScaleKeyframes{values: ${values}}';
  }

  ScaleKeyframesT unpack() =>
      ScaleKeyframesT(values: values?.map((e) => e.unpack()).toList());

  static int pack(fb.Builder fbBuilder, ScaleKeyframesT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class ScaleKeyframesT implements fb.Packable {
  List<Vec3T>? values;

  ScaleKeyframesT({this.values});

  @override
  int pack(fb.Builder fbBuilder) {
    int? valuesOffset;
    if (values != null) {
      for (var e in values!) {
        e.pack(fbBuilder);
      }
      valuesOffset = fbBuilder.endStructVector(values!.length);
    }
    fbBuilder.startTable(1);
    fbBuilder.addOffset(0, valuesOffset);
    return fbBuilder.endTable();
  }

  @override
  String toString() {
    return 'ScaleKeyframesT{values: ${values}}';
  }
}

class _ScaleKeyframesReader extends fb.TableReader<ScaleKeyframes> {
  const _ScaleKeyframesReader();

  @override
  ScaleKeyframes createObject(fb.BufferContext bc, int offset) =>
      ScaleKeyframes._(bc, offset);
}

class ScaleKeyframesBuilder {
  ScaleKeyframesBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(1);
  }

  int addValuesOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class ScaleKeyframesObjectBuilder extends fb.ObjectBuilder {
  final List<Vec3ObjectBuilder>? _values;

  ScaleKeyframesObjectBuilder({
    List<Vec3ObjectBuilder>? values,
  }) : _values = values;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? valuesOffset =
        _values == null ? null : fbBuilder.writeListOfStructs(_values!);
    fbBuilder.startTable(1);
    fbBuilder.addOffset(0, valuesOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

class Channel {
  Channel._(this._bc, this._bcOffset);
  factory Channel(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Channel> reader = _ChannelReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  int get node => const fb.Int32Reader().vTableGet(_bc, _bcOffset, 4, 0);
  List<double>? get timeline => const fb.ListReader<double>(fb.Float32Reader())
      .vTableGetNullable(_bc, _bcOffset, 6);
  KeyframesTypeId? get keyframesType => KeyframesTypeId._createOrNull(
      const fb.Uint8Reader().vTableGetNullable(_bc, _bcOffset, 8));
  dynamic get keyframes {
    switch (keyframesType?.value) {
      case 1:
        return TranslationKeyframes.reader
            .vTableGetNullable(_bc, _bcOffset, 10);
      case 2:
        return RotationKeyframes.reader.vTableGetNullable(_bc, _bcOffset, 10);
      case 3:
        return ScaleKeyframes.reader.vTableGetNullable(_bc, _bcOffset, 10);
      default:
        return null;
    }
  }

  @override
  String toString() {
    return 'Channel{node: ${node}, timeline: ${timeline}, keyframesType: ${keyframesType}, keyframes: ${keyframes}}';
  }

  ChannelT unpack() => ChannelT(
      node: node,
      timeline: const fb.ListReader<double>(fb.Float32Reader(), lazy: false)
          .vTableGetNullable(_bc, _bcOffset, 6),
      keyframesType: keyframesType,
      keyframes: keyframes);

  static int pack(fb.Builder fbBuilder, ChannelT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class ChannelT implements fb.Packable {
  int node;
  List<double>? timeline;
  KeyframesTypeId? keyframesType;
  dynamic keyframes;

  ChannelT({this.node = 0, this.timeline, this.keyframesType, this.keyframes});

  @override
  int pack(fb.Builder fbBuilder) {
    final int? timelineOffset =
        timeline == null ? null : fbBuilder.writeListFloat32(timeline!);
    final int? keyframesOffset = keyframes?.pack(fbBuilder);
    fbBuilder.startTable(4);
    fbBuilder.addInt32(0, node);
    fbBuilder.addOffset(1, timelineOffset);
    fbBuilder.addUint8(2, keyframesType?.value);
    fbBuilder.addOffset(3, keyframesOffset);
    return fbBuilder.endTable();
  }

  @override
  String toString() {
    return 'ChannelT{node: ${node}, timeline: ${timeline}, keyframesType: ${keyframesType}, keyframes: ${keyframes}}';
  }
}

class _ChannelReader extends fb.TableReader<Channel> {
  const _ChannelReader();

  @override
  Channel createObject(fb.BufferContext bc, int offset) =>
      Channel._(bc, offset);
}

class ChannelBuilder {
  ChannelBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(4);
  }

  int addNode(int? node) {
    fbBuilder.addInt32(0, node);
    return fbBuilder.offset;
  }

  int addTimelineOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }

  int addKeyframesType(KeyframesTypeId? keyframesType) {
    fbBuilder.addUint8(2, keyframesType?.value);
    return fbBuilder.offset;
  }

  int addKeyframesOffset(int? offset) {
    fbBuilder.addOffset(3, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class ChannelObjectBuilder extends fb.ObjectBuilder {
  final int? _node;
  final List<double>? _timeline;
  final KeyframesTypeId? _keyframesType;
  final dynamic _keyframes;

  ChannelObjectBuilder({
    int? node,
    List<double>? timeline,
    KeyframesTypeId? keyframesType,
    dynamic keyframes,
  })  : _node = node,
        _timeline = timeline,
        _keyframesType = keyframesType,
        _keyframes = keyframes;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? timelineOffset =
        _timeline == null ? null : fbBuilder.writeListFloat32(_timeline!);
    final int? keyframesOffset = _keyframes?.getOrCreateOffset(fbBuilder);
    fbBuilder.startTable(4);
    fbBuilder.addInt32(0, _node);
    fbBuilder.addOffset(1, timelineOffset);
    fbBuilder.addUint8(2, _keyframesType?.value);
    fbBuilder.addOffset(3, keyframesOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

class Animation {
  Animation._(this._bc, this._bcOffset);
  factory Animation(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Animation> reader = _AnimationReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  String? get name =>
      const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 4);
  List<Channel>? get channels => const fb.ListReader<Channel>(Channel.reader)
      .vTableGetNullable(_bc, _bcOffset, 6);

  @override
  String toString() {
    return 'Animation{name: ${name}, channels: ${channels}}';
  }

  AnimationT unpack() => AnimationT(
      name: name, channels: channels?.map((e) => e.unpack()).toList());

  static int pack(fb.Builder fbBuilder, AnimationT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class AnimationT implements fb.Packable {
  String? name;
  List<ChannelT>? channels;

  AnimationT({this.name, this.channels});

  @override
  int pack(fb.Builder fbBuilder) {
    final int? nameOffset = name == null ? null : fbBuilder.writeString(name!);
    final int? channelsOffset = channels == null
        ? null
        : fbBuilder.writeList(channels!.map((b) => b.pack(fbBuilder)).toList());
    fbBuilder.startTable(2);
    fbBuilder.addOffset(0, nameOffset);
    fbBuilder.addOffset(1, channelsOffset);
    return fbBuilder.endTable();
  }

  @override
  String toString() {
    return 'AnimationT{name: ${name}, channels: ${channels}}';
  }
}

class _AnimationReader extends fb.TableReader<Animation> {
  const _AnimationReader();

  @override
  Animation createObject(fb.BufferContext bc, int offset) =>
      Animation._(bc, offset);
}

class AnimationBuilder {
  AnimationBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(2);
  }

  int addNameOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }

  int addChannelsOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class AnimationObjectBuilder extends fb.ObjectBuilder {
  final String? _name;
  final List<ChannelObjectBuilder>? _channels;

  AnimationObjectBuilder({
    String? name,
    List<ChannelObjectBuilder>? channels,
  })  : _name = name,
        _channels = channels;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? nameOffset =
        _name == null ? null : fbBuilder.writeString(_name!);
    final int? channelsOffset = _channels == null
        ? null
        : fbBuilder.writeList(
            _channels!.map((b) => b.getOrCreateOffset(fbBuilder)).toList());
    fbBuilder.startTable(2);
    fbBuilder.addOffset(0, nameOffset);
    fbBuilder.addOffset(1, channelsOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

class Skin {
  Skin._(this._bc, this._bcOffset);
  factory Skin(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Skin> reader = _SkinReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  List<int>? get joints => const fb.ListReader<int>(fb.Int32Reader())
      .vTableGetNullable(_bc, _bcOffset, 4);
  List<Matrix>? get inverseBindMatrices =>
      const fb.ListReader<Matrix>(Matrix.reader)
          .vTableGetNullable(_bc, _bcOffset, 6);

  ///  The root joint of the skeleton.
  int get skeleton => const fb.Int32Reader().vTableGet(_bc, _bcOffset, 8, 0);

  @override
  String toString() {
    return 'Skin{joints: ${joints}, inverseBindMatrices: ${inverseBindMatrices}, skeleton: ${skeleton}}';
  }

  SkinT unpack() => SkinT(
      joints: const fb.ListReader<int>(fb.Int32Reader(), lazy: false)
          .vTableGetNullable(_bc, _bcOffset, 4),
      inverseBindMatrices: inverseBindMatrices?.map((e) => e.unpack()).toList(),
      skeleton: skeleton);

  static int pack(fb.Builder fbBuilder, SkinT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class SkinT implements fb.Packable {
  List<int>? joints;
  List<MatrixT>? inverseBindMatrices;

  ///  The root joint of the skeleton.
  int skeleton;

  SkinT({this.joints, this.inverseBindMatrices, this.skeleton = 0});

  @override
  int pack(fb.Builder fbBuilder) {
    final int? jointsOffset =
        joints == null ? null : fbBuilder.writeListInt32(joints!);
    int? inverseBindMatricesOffset;
    if (inverseBindMatrices != null) {
      for (var e in inverseBindMatrices!) {
        e.pack(fbBuilder);
      }
      inverseBindMatricesOffset =
          fbBuilder.endStructVector(inverseBindMatrices!.length);
    }
    fbBuilder.startTable(3);
    fbBuilder.addOffset(0, jointsOffset);
    fbBuilder.addOffset(1, inverseBindMatricesOffset);
    fbBuilder.addInt32(2, skeleton);
    return fbBuilder.endTable();
  }

  @override
  String toString() {
    return 'SkinT{joints: ${joints}, inverseBindMatrices: ${inverseBindMatrices}, skeleton: ${skeleton}}';
  }
}

class _SkinReader extends fb.TableReader<Skin> {
  const _SkinReader();

  @override
  Skin createObject(fb.BufferContext bc, int offset) => Skin._(bc, offset);
}

class SkinBuilder {
  SkinBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(3);
  }

  int addJointsOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }

  int addInverseBindMatricesOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }

  int addSkeleton(int? skeleton) {
    fbBuilder.addInt32(2, skeleton);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class SkinObjectBuilder extends fb.ObjectBuilder {
  final List<int>? _joints;
  final List<MatrixObjectBuilder>? _inverseBindMatrices;
  final int? _skeleton;

  SkinObjectBuilder({
    List<int>? joints,
    List<MatrixObjectBuilder>? inverseBindMatrices,
    int? skeleton,
  })  : _joints = joints,
        _inverseBindMatrices = inverseBindMatrices,
        _skeleton = skeleton;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? jointsOffset =
        _joints == null ? null : fbBuilder.writeListInt32(_joints!);
    final int? inverseBindMatricesOffset = _inverseBindMatrices == null
        ? null
        : fbBuilder.writeListOfStructs(_inverseBindMatrices!);
    fbBuilder.startTable(3);
    fbBuilder.addOffset(0, jointsOffset);
    fbBuilder.addOffset(1, inverseBindMatricesOffset);
    fbBuilder.addInt32(2, _skeleton);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

///  Scene graph.
///
class Matrix {
  Matrix._(this._bc, this._bcOffset);

  static const fb.Reader<Matrix> reader = _MatrixReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  double get m0 => const fb.Float32Reader().read(_bc, _bcOffset + 0);
  double get m1 => const fb.Float32Reader().read(_bc, _bcOffset + 4);
  double get m2 => const fb.Float32Reader().read(_bc, _bcOffset + 8);
  double get m3 => const fb.Float32Reader().read(_bc, _bcOffset + 12);
  double get m4 => const fb.Float32Reader().read(_bc, _bcOffset + 16);
  double get m5 => const fb.Float32Reader().read(_bc, _bcOffset + 20);
  double get m6 => const fb.Float32Reader().read(_bc, _bcOffset + 24);
  double get m7 => const fb.Float32Reader().read(_bc, _bcOffset + 28);
  double get m8 => const fb.Float32Reader().read(_bc, _bcOffset + 32);
  double get m9 => const fb.Float32Reader().read(_bc, _bcOffset + 36);
  double get m10 => const fb.Float32Reader().read(_bc, _bcOffset + 40);
  double get m11 => const fb.Float32Reader().read(_bc, _bcOffset + 44);
  double get m12 => const fb.Float32Reader().read(_bc, _bcOffset + 48);
  double get m13 => const fb.Float32Reader().read(_bc, _bcOffset + 52);
  double get m14 => const fb.Float32Reader().read(_bc, _bcOffset + 56);
  double get m15 => const fb.Float32Reader().read(_bc, _bcOffset + 60);

  @override
  String toString() {
    return 'Matrix{m0: ${m0}, m1: ${m1}, m2: ${m2}, m3: ${m3}, m4: ${m4}, m5: ${m5}, m6: ${m6}, m7: ${m7}, m8: ${m8}, m9: ${m9}, m10: ${m10}, m11: ${m11}, m12: ${m12}, m13: ${m13}, m14: ${m14}, m15: ${m15}}';
  }

  MatrixT unpack() => MatrixT(
      m0: m0,
      m1: m1,
      m2: m2,
      m3: m3,
      m4: m4,
      m5: m5,
      m6: m6,
      m7: m7,
      m8: m8,
      m9: m9,
      m10: m10,
      m11: m11,
      m12: m12,
      m13: m13,
      m14: m14,
      m15: m15);

  static int pack(fb.Builder fbBuilder, MatrixT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

///  Scene graph.
///
class MatrixT implements fb.Packable {
  double m0;
  double m1;
  double m2;
  double m3;
  double m4;
  double m5;
  double m6;
  double m7;
  double m8;
  double m9;
  double m10;
  double m11;
  double m12;
  double m13;
  double m14;
  double m15;

  MatrixT(
      {required this.m0,
      required this.m1,
      required this.m2,
      required this.m3,
      required this.m4,
      required this.m5,
      required this.m6,
      required this.m7,
      required this.m8,
      required this.m9,
      required this.m10,
      required this.m11,
      required this.m12,
      required this.m13,
      required this.m14,
      required this.m15});

  @override
  int pack(fb.Builder fbBuilder) {
    fbBuilder.putFloat32(m15);
    fbBuilder.putFloat32(m14);
    fbBuilder.putFloat32(m13);
    fbBuilder.putFloat32(m12);
    fbBuilder.putFloat32(m11);
    fbBuilder.putFloat32(m10);
    fbBuilder.putFloat32(m9);
    fbBuilder.putFloat32(m8);
    fbBuilder.putFloat32(m7);
    fbBuilder.putFloat32(m6);
    fbBuilder.putFloat32(m5);
    fbBuilder.putFloat32(m4);
    fbBuilder.putFloat32(m3);
    fbBuilder.putFloat32(m2);
    fbBuilder.putFloat32(m1);
    fbBuilder.putFloat32(m0);
    return fbBuilder.offset;
  }

  @override
  String toString() {
    return 'MatrixT{m0: ${m0}, m1: ${m1}, m2: ${m2}, m3: ${m3}, m4: ${m4}, m5: ${m5}, m6: ${m6}, m7: ${m7}, m8: ${m8}, m9: ${m9}, m10: ${m10}, m11: ${m11}, m12: ${m12}, m13: ${m13}, m14: ${m14}, m15: ${m15}}';
  }
}

class _MatrixReader extends fb.StructReader<Matrix> {
  const _MatrixReader();

  @override
  int get size => 64;

  @override
  Matrix createObject(fb.BufferContext bc, int offset) => Matrix._(bc, offset);
}

class MatrixBuilder {
  MatrixBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  int finish(
      double m0,
      double m1,
      double m2,
      double m3,
      double m4,
      double m5,
      double m6,
      double m7,
      double m8,
      double m9,
      double m10,
      double m11,
      double m12,
      double m13,
      double m14,
      double m15) {
    fbBuilder.putFloat32(m15);
    fbBuilder.putFloat32(m14);
    fbBuilder.putFloat32(m13);
    fbBuilder.putFloat32(m12);
    fbBuilder.putFloat32(m11);
    fbBuilder.putFloat32(m10);
    fbBuilder.putFloat32(m9);
    fbBuilder.putFloat32(m8);
    fbBuilder.putFloat32(m7);
    fbBuilder.putFloat32(m6);
    fbBuilder.putFloat32(m5);
    fbBuilder.putFloat32(m4);
    fbBuilder.putFloat32(m3);
    fbBuilder.putFloat32(m2);
    fbBuilder.putFloat32(m1);
    fbBuilder.putFloat32(m0);
    return fbBuilder.offset;
  }
}

class MatrixObjectBuilder extends fb.ObjectBuilder {
  final double _m0;
  final double _m1;
  final double _m2;
  final double _m3;
  final double _m4;
  final double _m5;
  final double _m6;
  final double _m7;
  final double _m8;
  final double _m9;
  final double _m10;
  final double _m11;
  final double _m12;
  final double _m13;
  final double _m14;
  final double _m15;

  MatrixObjectBuilder({
    required double m0,
    required double m1,
    required double m2,
    required double m3,
    required double m4,
    required double m5,
    required double m6,
    required double m7,
    required double m8,
    required double m9,
    required double m10,
    required double m11,
    required double m12,
    required double m13,
    required double m14,
    required double m15,
  })  : _m0 = m0,
        _m1 = m1,
        _m2 = m2,
        _m3 = m3,
        _m4 = m4,
        _m5 = m5,
        _m6 = m6,
        _m7 = m7,
        _m8 = m8,
        _m9 = m9,
        _m10 = m10,
        _m11 = m11,
        _m12 = m12,
        _m13 = m13,
        _m14 = m14,
        _m15 = m15;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    fbBuilder.putFloat32(_m15);
    fbBuilder.putFloat32(_m14);
    fbBuilder.putFloat32(_m13);
    fbBuilder.putFloat32(_m12);
    fbBuilder.putFloat32(_m11);
    fbBuilder.putFloat32(_m10);
    fbBuilder.putFloat32(_m9);
    fbBuilder.putFloat32(_m8);
    fbBuilder.putFloat32(_m7);
    fbBuilder.putFloat32(_m6);
    fbBuilder.putFloat32(_m5);
    fbBuilder.putFloat32(_m4);
    fbBuilder.putFloat32(_m3);
    fbBuilder.putFloat32(_m2);
    fbBuilder.putFloat32(_m1);
    fbBuilder.putFloat32(_m0);
    return fbBuilder.offset;
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

class Node {
  Node._(this._bc, this._bcOffset);
  factory Node(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Node> reader = _NodeReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  String? get name =>
      const fb.StringReader().vTableGetNullable(_bc, _bcOffset, 4);
  List<int>? get children => const fb.ListReader<int>(fb.Int32Reader())
      .vTableGetNullable(_bc, _bcOffset, 6);
  Matrix? get transform => Matrix.reader.vTableGetNullable(_bc, _bcOffset, 8);
  List<MeshPrimitive>? get meshPrimitives =>
      const fb.ListReader<MeshPrimitive>(MeshPrimitive.reader)
          .vTableGetNullable(_bc, _bcOffset, 10);
  Skin? get skin => Skin.reader.vTableGetNullable(_bc, _bcOffset, 12);

  @override
  String toString() {
    return 'Node{name: ${name}, children: ${children}, transform: ${transform}, meshPrimitives: ${meshPrimitives}, skin: ${skin}}';
  }

  NodeT unpack() => NodeT(
      name: name,
      children: const fb.ListReader<int>(fb.Int32Reader(), lazy: false)
          .vTableGetNullable(_bc, _bcOffset, 6),
      transform: transform?.unpack(),
      meshPrimitives: meshPrimitives?.map((e) => e.unpack()).toList(),
      skin: skin?.unpack());

  static int pack(fb.Builder fbBuilder, NodeT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class NodeT implements fb.Packable {
  String? name;
  List<int>? children;
  MatrixT? transform;
  List<MeshPrimitiveT>? meshPrimitives;
  SkinT? skin;

  NodeT(
      {this.name,
      this.children,
      this.transform,
      this.meshPrimitives,
      this.skin});

  @override
  int pack(fb.Builder fbBuilder) {
    final int? nameOffset = name == null ? null : fbBuilder.writeString(name!);
    final int? childrenOffset =
        children == null ? null : fbBuilder.writeListInt32(children!);
    final int? meshPrimitivesOffset = meshPrimitives == null
        ? null
        : fbBuilder
            .writeList(meshPrimitives!.map((b) => b.pack(fbBuilder)).toList());
    final int? skinOffset = skin?.pack(fbBuilder);
    fbBuilder.startTable(5);
    fbBuilder.addOffset(0, nameOffset);
    fbBuilder.addOffset(1, childrenOffset);
    if (transform != null) {
      fbBuilder.addStruct(2, transform!.pack(fbBuilder));
    }
    fbBuilder.addOffset(3, meshPrimitivesOffset);
    fbBuilder.addOffset(4, skinOffset);
    return fbBuilder.endTable();
  }

  @override
  String toString() {
    return 'NodeT{name: ${name}, children: ${children}, transform: ${transform}, meshPrimitives: ${meshPrimitives}, skin: ${skin}}';
  }
}

class _NodeReader extends fb.TableReader<Node> {
  const _NodeReader();

  @override
  Node createObject(fb.BufferContext bc, int offset) => Node._(bc, offset);
}

class NodeBuilder {
  NodeBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(5);
  }

  int addNameOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }

  int addChildrenOffset(int? offset) {
    fbBuilder.addOffset(1, offset);
    return fbBuilder.offset;
  }

  int addTransform(int offset) {
    fbBuilder.addStruct(2, offset);
    return fbBuilder.offset;
  }

  int addMeshPrimitivesOffset(int? offset) {
    fbBuilder.addOffset(3, offset);
    return fbBuilder.offset;
  }

  int addSkinOffset(int? offset) {
    fbBuilder.addOffset(4, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class NodeObjectBuilder extends fb.ObjectBuilder {
  final String? _name;
  final List<int>? _children;
  final MatrixObjectBuilder? _transform;
  final List<MeshPrimitiveObjectBuilder>? _meshPrimitives;
  final SkinObjectBuilder? _skin;

  NodeObjectBuilder({
    String? name,
    List<int>? children,
    MatrixObjectBuilder? transform,
    List<MeshPrimitiveObjectBuilder>? meshPrimitives,
    SkinObjectBuilder? skin,
  })  : _name = name,
        _children = children,
        _transform = transform,
        _meshPrimitives = meshPrimitives,
        _skin = skin;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? nameOffset =
        _name == null ? null : fbBuilder.writeString(_name!);
    final int? childrenOffset =
        _children == null ? null : fbBuilder.writeListInt32(_children!);
    final int? meshPrimitivesOffset = _meshPrimitives == null
        ? null
        : fbBuilder.writeList(_meshPrimitives!
            .map((b) => b.getOrCreateOffset(fbBuilder))
            .toList());
    final int? skinOffset = _skin?.getOrCreateOffset(fbBuilder);
    fbBuilder.startTable(5);
    fbBuilder.addOffset(0, nameOffset);
    fbBuilder.addOffset(1, childrenOffset);
    if (_transform != null) {
      fbBuilder.addStruct(2, _transform!.finish(fbBuilder));
    }
    fbBuilder.addOffset(3, meshPrimitivesOffset);
    fbBuilder.addOffset(4, skinOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}

class Scene {
  Scene._(this._bc, this._bcOffset);
  factory Scene(List<int> bytes) {
    final rootRef = fb.BufferContext.fromBytes(bytes);
    return reader.read(rootRef, 0);
  }

  static const fb.Reader<Scene> reader = _SceneReader();

  final fb.BufferContext _bc;
  final int _bcOffset;

  List<int>? get children => const fb.ListReader<int>(fb.Int32Reader())
      .vTableGetNullable(_bc, _bcOffset, 4);
  Matrix? get transform => Matrix.reader.vTableGetNullable(_bc, _bcOffset, 6);
  List<Node>? get nodes => const fb.ListReader<Node>(Node.reader)
      .vTableGetNullable(_bc, _bcOffset, 8);
  List<Texture>? get textures => const fb.ListReader<Texture>(Texture.reader)
      .vTableGetNullable(_bc, _bcOffset, 10);
  List<Animation>? get animations =>
      const fb.ListReader<Animation>(Animation.reader)
          .vTableGetNullable(_bc, _bcOffset, 12);

  @override
  String toString() {
    return 'Scene{children: ${children}, transform: ${transform}, nodes: ${nodes}, textures: ${textures}, animations: ${animations}}';
  }

  SceneT unpack() => SceneT(
      children: const fb.ListReader<int>(fb.Int32Reader(), lazy: false)
          .vTableGetNullable(_bc, _bcOffset, 4),
      transform: transform?.unpack(),
      nodes: nodes?.map((e) => e.unpack()).toList(),
      textures: textures?.map((e) => e.unpack()).toList(),
      animations: animations?.map((e) => e.unpack()).toList());

  static int pack(fb.Builder fbBuilder, SceneT? object) {
    if (object == null) return 0;
    return object.pack(fbBuilder);
  }
}

class SceneT implements fb.Packable {
  List<int>? children;
  MatrixT? transform;
  List<NodeT>? nodes;
  List<TextureT>? textures;
  List<AnimationT>? animations;

  SceneT(
      {this.children,
      this.transform,
      this.nodes,
      this.textures,
      this.animations});

  @override
  int pack(fb.Builder fbBuilder) {
    final int? childrenOffset =
        children == null ? null : fbBuilder.writeListInt32(children!);
    final int? nodesOffset = nodes == null
        ? null
        : fbBuilder.writeList(nodes!.map((b) => b.pack(fbBuilder)).toList());
    final int? texturesOffset = textures == null
        ? null
        : fbBuilder.writeList(textures!.map((b) => b.pack(fbBuilder)).toList());
    final int? animationsOffset = animations == null
        ? null
        : fbBuilder
            .writeList(animations!.map((b) => b.pack(fbBuilder)).toList());
    fbBuilder.startTable(5);
    fbBuilder.addOffset(0, childrenOffset);
    if (transform != null) {
      fbBuilder.addStruct(1, transform!.pack(fbBuilder));
    }
    fbBuilder.addOffset(2, nodesOffset);
    fbBuilder.addOffset(3, texturesOffset);
    fbBuilder.addOffset(4, animationsOffset);
    return fbBuilder.endTable();
  }

  @override
  String toString() {
    return 'SceneT{children: ${children}, transform: ${transform}, nodes: ${nodes}, textures: ${textures}, animations: ${animations}}';
  }
}

class _SceneReader extends fb.TableReader<Scene> {
  const _SceneReader();

  @override
  Scene createObject(fb.BufferContext bc, int offset) => Scene._(bc, offset);
}

class SceneBuilder {
  SceneBuilder(this.fbBuilder);

  final fb.Builder fbBuilder;

  void begin() {
    fbBuilder.startTable(5);
  }

  int addChildrenOffset(int? offset) {
    fbBuilder.addOffset(0, offset);
    return fbBuilder.offset;
  }

  int addTransform(int offset) {
    fbBuilder.addStruct(1, offset);
    return fbBuilder.offset;
  }

  int addNodesOffset(int? offset) {
    fbBuilder.addOffset(2, offset);
    return fbBuilder.offset;
  }

  int addTexturesOffset(int? offset) {
    fbBuilder.addOffset(3, offset);
    return fbBuilder.offset;
  }

  int addAnimationsOffset(int? offset) {
    fbBuilder.addOffset(4, offset);
    return fbBuilder.offset;
  }

  int finish() {
    return fbBuilder.endTable();
  }
}

class SceneObjectBuilder extends fb.ObjectBuilder {
  final List<int>? _children;
  final MatrixObjectBuilder? _transform;
  final List<NodeObjectBuilder>? _nodes;
  final List<TextureObjectBuilder>? _textures;
  final List<AnimationObjectBuilder>? _animations;

  SceneObjectBuilder({
    List<int>? children,
    MatrixObjectBuilder? transform,
    List<NodeObjectBuilder>? nodes,
    List<TextureObjectBuilder>? textures,
    List<AnimationObjectBuilder>? animations,
  })  : _children = children,
        _transform = transform,
        _nodes = nodes,
        _textures = textures,
        _animations = animations;

  /// Finish building, and store into the [fbBuilder].
  @override
  int finish(fb.Builder fbBuilder) {
    final int? childrenOffset =
        _children == null ? null : fbBuilder.writeListInt32(_children!);
    final int? nodesOffset = _nodes == null
        ? null
        : fbBuilder.writeList(
            _nodes!.map((b) => b.getOrCreateOffset(fbBuilder)).toList());
    final int? texturesOffset = _textures == null
        ? null
        : fbBuilder.writeList(
            _textures!.map((b) => b.getOrCreateOffset(fbBuilder)).toList());
    final int? animationsOffset = _animations == null
        ? null
        : fbBuilder.writeList(
            _animations!.map((b) => b.getOrCreateOffset(fbBuilder)).toList());
    fbBuilder.startTable(5);
    fbBuilder.addOffset(0, childrenOffset);
    if (_transform != null) {
      fbBuilder.addStruct(1, _transform!.finish(fbBuilder));
    }
    fbBuilder.addOffset(2, nodesOffset);
    fbBuilder.addOffset(3, texturesOffset);
    fbBuilder.addOffset(4, animationsOffset);
    return fbBuilder.endTable();
  }

  /// Convenience method to serialize to byte list.
  @override
  Uint8List toBytes([String? fileIdentifier]) {
    final fbBuilder = fb.Builder(deduplicateTables: false);
    fbBuilder.finish(finish(fbBuilder), fileIdentifier);
    return fbBuilder.buffer;
  }
}
